# Advanced-Calculator

## Список поддерживаемых конструкций

|  Конструкция  | Имя                         | оп-ды | int | double | complex |
|:-------------:|-----------------------------|:-----:|:---:|:------:|:-------:|
|      `+`      | сложение                    |   2   |  +  |    +   |    +    |
|      `-`      | вычитание                   |   2   |  +  |    +   |    +    |
|      `*`      | умножение                   |   2   |  +  |    +   |    +    |
|      `/`      | деление                     |   2   |  +  |    +   |    +    |
|      `%`      | остаток от деления          |   2   |  +  |    -   |    -    |
|      `^`      | возведение в степень        |   2   |  +  |    +   |    -    |
|      `&`      | побитовое И                 |   2   |  +  |    -   |    -    |
|      `\|`     | побитовое ИЛИ               |   2   |  +  |    -   |    -    |
|      `@`      | симметрическая разность     |   2   |  +  |    -   |    -    |
|    `sin()`    | синус                       |   1   |  +  |    +   |    +    |
|    `cos()`    | косинус                     |   1   |  +  |    +   |    +    |
|     `ln()`    | натуральный логарифм        |   1   |  +  |    +   |    +    |
|    `log()`    | десятичный логарифм         |   1   |  +  |    +   |    +    |
|    `sqrt()`   | квадратный корень           |   1   |  +  |    +   |    +    |
|    `abs()`    | модуль числа                |   1   |  +  |    +   |    +    |
|    `exp()`    | экспонента                  |   1   |  +  |    +   |    +    |
|    `real()`   | действительная часть числа  |   1   |  +  |    +   |    +    |
|    `imag()`   | комплексная часть числа     |   1   |  +  |    +   |    +    |
|    `mag()`    | модуль комплексного числа   |   1   |  +  |    +   |    +    |
|   `phase()`   | аргумент комплексного числа |   1   |  +  |    +   |    +    |
|    `pow()`    | возведение в степень        |   2   |  +  |    +   |    +    |
|    `min()`    | минимум                     |   2   |  +  |    +   |    -    |
|    `max()`    | максимум                    |   2   |  +  |    +   |    -    |
|      `pi`     | число Пи                    |   0   |  -  |    -   |    -    |
|      `e`      | число Эйлера                |   0   |  -  |    -   |    -    |
|      `j`      | мнимая единица              |   0   |  -  |    -   |    -    |

## Формат входных данных

- На вход подается одно или несколько выражений.
- Выражения могут содержать переменные.
   - Для удачного подсчета, кол-во переменных равняется или меньше кол-ву входных строк.-
- Строки могут содержать коментарии, отмеченные '#', пробелы, табуляции или быть пустыми.
- Пример
```text
exp(-j*PI*alpha*len/v0) # финальное выражение
alpha = sqrt(PI*len/(s1+s2))
s1 = cos(real(S11)*real(S22)) 
s2 = (sin(imag(S11*S22)))^2
len = 191.76 
v0 = 299.799 # скорость
S11 = -0.01-0.92j 
S22 = 0.0001+0.997j
#S22 = 0.0002+0.995j
```
## Алгоритм работы

1) Особенности алгоритма работы парсера
   - Построчно считывает входной файл
   - Опускает пробелы, комментарии, табуляции и пустые выражения
   - Делит выражения на смысловые математические части 
   - Только латинские буквы    
   - Пример работы
    ```text
   Входная строчка: 
   a = 2 + min(2, 3) 
   
   Структура с обработанными данными:
   varname ["a"];
   formula ["2", "+", "min", "(", "2", "," , "3" , ")"] 
   dependencies = ø
    ```
   - Имеется проверка на рекурсивное определение переменных и выстраивание порядка подсчета по кол-ву зависимостей от переменных, если строк больше одной.
     * Строим ориентированный граф, вершинами которого являются переменные.
     * Ребро графа (`a`, `b`) означает, что `a` при подсчете зависима от `b`.
     * С помощью DFS: 
       находим циклы (рекурсивное определение переменных), если такое есть, считает от скольки переменных зависит каждая переменная.

2) Особенности алгоритмп работы RPN
   - Обрабатывает левосторонние и правосторонние операции
   - Умеет обрабатывать функции 

3) Алгоритм работы дерева
    
4)